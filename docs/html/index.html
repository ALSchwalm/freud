<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>freud: Freud</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">freud
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Freud </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><code>freud</code> is a C++ header-only library for finding structures in a running process's memory.</p>
<h2>Installation </h2>
<p>As a header-only library, no installation is required. <code>freud</code> supports any C++98 or newer compiler. To use it, simply clone this project or download the zip file and add the 'freud' directory to your C++ project's include path.</p>
<h2>Usage </h2>
<p>Using <code>freud</code> has three major components:</p>
<ul>
<li>Defining a <code>MemoryObject</code></li>
<li>Creating a <code>MemoryContext</code></li>
<li>Scanning the context for your objects</li>
</ul>
<p>These steps are detailed below:</p>
<h2>Defining a MemoryObject </h2>
<p>A <code>MemoryObject</code> represents some series of constraints used to verify that a particular collection of bytes are an instance of some type. For example, suppose that you know you are looking for a structure that has the following layout: </p><pre class="fragment">struct Position {
    int x;
    int y;
}
</pre><p>This alone would not be enough to locate the structure. We need some type of constraint or element to use to narrow down the search. In this case, suppose we know that the 'x' position is equal to 10 and we want to find the 'y' position. Then we could define a <code>MemoryObject</code> like this: </p><pre class="fragment">class PositionMatcher : public MemoryObject&lt;Position&gt; {
    static bool verify(const Position&amp; p) {
        return p.x == 10;
    }
}
</pre><p>The core of this definition is the <code>verify</code> member function. This function will be passed an object created from bytes in a <code>MemoryContext</code>. The user must determine whether the provided object has the properties they expect. In this case, we test whether the 'x' member has the expected value.</p>
<h2>Creating a <code>MemoryContext</code> </h2>
<p>A <code>MemoryContext</code> represents a generic interface to some collection of memory. Typically, this will be a running process's memory. This interface can be used to read bytes from another process's virtual address space.</p>
<p>In general, a <code>MemoryContext</code> can be created from whatever the process ID equivalent is on a given platform. Suppose that the 'Xorg' process on my target has a PID of 659. Then I can create a context for that processes with </p><pre class="fragment">MemoryContext ctx(659);
</pre><p>Note that reading from a <code>MemoryContext</code> may require elevated permissions on some platforms. Specifically, the user must be root on Linux. However, Windows processes may read each other's memory provided that have the same permissions.</p>
<h2>Scanning the context for your objects </h2>
<p>A <code>MemoryContext</code> will provide two member functions for scanning the memory it wraps: <code>scan_once</code> and <code>scan_forever</code>. These return a <code>MemoryContextIterator</code>, which is a type representing a pointer into some process memory. When dereferenced, the iterator will return a reference to an instance of the target structure that passes the 'verify' test of the matcher. For example, a user could print all of the <code>Positions</code> with the following code: </p><pre class="fragment">MemoryContextIterator&lt;PositionMatcher&gt; iter = ctx.scan_once&lt;PositionMatcher&gt;();

for(; iter != ctx.end(); ++iter) {
    std::cout &lt;&lt; "Position: x=" &lt;&lt; iter-&gt;x &lt;&lt; ", y=" &lt;&lt; iter-&gt;y &lt;&lt; "\n";
}
</pre><p>The <code>scan_forever</code> function is similar. However the <code>MemoryContextIterator</code> returned by this function will never equal <code>ctx.end()</code>. Instead, it will wrap around and start scanning memory again when it reaches the end. This is useful for making a real-time scraping program.</p>
<p>Note however, that a given <code>MemoryContext</code> object should only have one continuous (i.e., returned from <code>scan_forever</code>) object at a time. Incrementing an iterator of this kind will invalidate all other iterators into the context. Multiple single pass (i.e., returned from <code>scan_once</code>) iterators may be used at the same time. Additionally, multiple contexts may refer to the same process.</p>
<h2>Putting it all together </h2>
<p>A complete example to print all of the <code>Position</code> objects would therefore look like this: </p><pre class="fragment">#include "freud/freud.hpp"
#include &lt;iostream&gt; // for streams
#include &lt;cstdlib&gt;  // for atoi

struct Position {
    int x;
    int y;
};

class PositionMatcher : public MemoryObject&lt;Position&gt; {
    static bool verify(const Position&amp; p) {
        return p.x == 10;
    }
};

int main(int argc, char** argv) {
    MemoryContext ctx(atoi(argv[1]));

    MemoryContextIterator&lt;PositionMatcher&gt; iter =
        ctx.scan_once&lt;PositionMatcher&gt;();

    for(; iter != ctx.end(); ++iter) {
        std::cout &lt;&lt; "Position: x=" &lt;&lt; iter-&gt;x &lt;&lt; ", y=" &lt;&lt; iter-&gt;y &lt;&lt; "\n";
    }
}
</pre><h2>Contributing </h2>
<p>This project is currently in a somewhat unstable state, so things may change. That being said, contributions are welcome.</p>
<h2>Library </h2>
<p>This project is released under the terms of the MIT license. See the LICENSE file for details. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
